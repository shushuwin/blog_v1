import logging
import numpy as np
from pathlib import Path
from typing import Optional
import os

try:
    import lightgbm as lgb
    from thrember.features import PEFeatureExtractor
except Exception:
    lgb = None
    PEFeatureExtractor = None

class ScannerConfig:
    def __init__(self, model_dir: str, threshold: float = 0.5):
        self.MODEL_DIR = model_dir
        self.THRESHOLD = threshold

class MalwareScanner:
    def __init__(self, model_dir: str, threshold: float = 0.5):
        self.model_dir = Path(model_dir)
        self.threshold = threshold
        self.models = []
        self.extractor: Optional[PEFeatureExtractor] = None
        self.logger = logging.getLogger(__name__)
        self.initialized = False

    def ensure_initialized(self):
        if self.initialized:
            return True
        if PEFeatureExtractor is None or lgb is None:
            self.logger.warning("Malware scanner dependencies not available; using fallback")
            self.initialized = True
            return False
        try:
            self.extractor = PEFeatureExtractor()
            files = sorted(self.model_dir.glob("model_fold*.txt"))
            if len(files) == 0:
                self.logger.warning(f"No model files found in {self.model_dir}")
            for f in files:
                self.models.append(lgb.Booster(model_file=str(f)))
            self.initialized = True
            return True
        except Exception as e:
            self.logger.error(f"Scanner init error: {e}")
            self.initialized = True
            return False

    def predict(self, data: bytes):
        ready = self.ensure_initialized()
        if not ready or len(self.models) == 0 or self.extractor is None:
            s = 0.5
            l = data.lower()
            if b"malware" in l or b"virus" in l:
                s = 0.9
            return ("malicious" if s >= 0.7 else "benign", s)
        try:
            feats = self.extractor.feature_vector(data)
            if feats is None:
                raise ValueError("Feature extraction failed")
            feats = np.array(feats, dtype=np.float32)
            scores = [float(m.predict([feats])[0]) for m in self.models]
            ensemble = float(np.mean(scores))
            return ("malicious" if ensemble >= self.threshold else "benign", ensemble)
        except Exception as e:
            self.logger.error(f"Predict error: {e}")
            return ("benign", 0.5)